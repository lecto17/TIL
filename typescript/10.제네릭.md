* 제네릭 소개

  - 마치 타입을 함수의 파라미터로 받는 것과 같다.

* 제네릭의 기본 문법

  ```
     function logText(text) {
	console.log(text);
	return text;
     }

     logText(10); // 숫자 10
     logText('하이'); // 문자열 하이
     logText(true); // 진위값 true



     function logText<T>(text: T): T {
	console.log(text);
	return text;
     }

     logText(); // logText()에 마우스를 올려보면 함수의 스펙을 보여주는데, function logText<unknown>(text: unknown): unknown 이라고 나온다. 이 말인 즉, logText()를 호출할 때 전달되는 인자의 타입을 같이 전달해주겠다는 것.

     logText<string>('하이';)

  ```


* 기존 타입 정의 방식과 제네릭의 차이점 - 함수 중복 선언의 단점
   
   ```
      function logText(text: string) {
	console.log(text);
	return text;
      }

      function logText(num: number) {
	console.log(num);
	return num;
      }

      위에와 아래는 동일한 로직의 코드인데, parameter로 받는 인자의 타입만 다르다. 파라미터 타입의 차이만 있는데, 위와 같이 함수를 나누는 것은 유지 보수에 있어 안좋다.
   ```


* 기존 문법과 제네릭의 차이점 - 유니온 타입을 이용한 선언 방식의 문제점
   
   ```
      function logText(text: string | number) { // 전달인자로 string 혹은 number 타입, 두 타입을 모두 받을 수 있다.
        이런 경우 text. 으로 접근했을 때, string과 number 타입의 공집합인 즉, string, number에서 모두 사용될 수 있는 API들만 자동완성에 띄워진다는 문제점이 있다.

      }

      const a = logText('a'); // logText 함수의 return 되는 것의 타입이 어떤 것인지 몰라 제한적으로 사용될 수 밖에 없다는 단점이 있다.
   ```


* 제네릭의 장점과 타입 추론에서의 이점



* 제네릭 실전 예제 살펴보기 - 예제 설명



* 제네릭 실전 예제 살펴보기 - 코드에 타입 정의하기


* 인터페이스에 제네릭을 선언하는 방법



* 제네릭 실전 예제 살펴보기 - 제네릭을 이용한 타입 정의



* 제네릭의 타입 제한



* 정의된 타입으로 타입을 제한하기



* keyof로 제네릭의 타입 제한하기


