* 인터페이스 소개 및 변수를 정의하는 인터페이스

  ```
    interface User {
       age: number,
       name: string,
    }

    // 변수에 인터페이스 활용
    let seho: User = { // seho를User 타입으로 선언했을 경우 User 타입에 해당하는 속성인 age와 name을 선언해줘야 한다.
       age: 33,
       name: "seho",
    }

    // 함수에 인터페이스 활용
    function getUser(user) {
       ....
    }

    위와 같이 선언해줬을 경우, 어떤 타입의 파라미터이든 getUser의 전달인자로 들어갈 수 있게된다. 따라서 User 타입의 전달인자만 넣게 하려면 아래와 같이 해야한다.

    function getUser(user: User) {
       ...
    }

    만약 아래와 같은 변수를 위 getUser함수에 전달인자로 보내면 에러가 발생한다.

    const capt = {
      name: "캡틴"
    }

    
  ```


* 함수의 인자를 정의하는 인터페이스
  
  위에서 설명 추가

  <br/>

* 함수 구조를 정의하는 인터페이스

  ```
     // 함수의 스펙(구조)에 인터페이스를 활용
     // SumFunction 함수의 스펙을 설정
     // 해당 타입의 함수는 인자를 두개를 받으며 그 두 인자는 number 타입임을 명시하는 것, 그리고 반환 타입도 number 타입임을 나타내는 것:wq
     interface SumFunction {
	(a: number, b: number): number;
     }
  ```


* 인덱싱 방식을 정의하는 인터페이스
  
  ```
    interface StringArray { // index는 number, index에 해당하는 값은 string
      [index: number]: string;
    }

    let arr: StringArray = ["a", "b", "c"];

    arr[0] = 10 // error
  ```


* 인터페이스 딕셔너리 패턴

  ```
    interface StringRegexDictionary {
      [key: string]: RegExp;
    }

    let obj: StringRegexDictionary = {
       cssFile: 'css' // 오류 출력, 정규표현식이 와야할 자리에 'css'라는 문자열이 왔기에.
       cssFile: /\.css$/ //.css 확장자 파일을 가진 모든 파일을 들고 오는 정규식
       jsFile: /\.js$/
    }

    인터페이스를 사용함으로써, 객체 내에 값을 생성할 때 정해진 방식대로의 값만을 넣을 수 있다.
  ```

* 인터페이스 확장(상속)
  
   ```
     interface Person {
       name: string;
       age: number;
     }

     interface Developer extends Person{
	language: string;
     }


     let capt: Developer = { // Developer 타입의 변수를 생성할 때는 Person 타입의 값들도 정의해야 한다.
        language: 'ts',
	age: 100,
	name: "캡틴"
     }
   ```


